{"ast":null,"code":"import { useState, useEffect } from 'react';\n\n// chatHelpers.js\nexport async function fetchBotReply(messageId, chatHistory, updateBotReply, persona, dispatch) {\n  try {\n    const cutoffString = `\",\\n    \"content\": \"`;\n    const cPrompt = JSON.stringify(chatHistory, null, 2);\n    const cutoffIndex = cPrompt.lastIndexOf(cutoffString);\n    const chatPrompt = cPrompt.substring(0, cutoffIndex + cutoffString.length);\n    const systemPrompt = JSON.stringify(persona, null, 2);\n    const finalPrompt = `${systemPrompt}\\n\\n${chatPrompt}`;\n    console.log('-'.repeat(12)); // Corrected '*' to '-' and use 'repeat'\n    console.log(finalPrompt);\n    console.log();\n    dispatch({\n      type: 'SET_LOADING_STATE',\n      payload: true\n    });\n    const response = await fetch('http://localhost:11434/api/generate', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        model: persona.model,\n        prompt: finalPrompt\n      })\n    });\n    if (!response.ok) {\n      throw new Error(`HTTP error! Status: ${response.status}`);\n    }\n    const reader = response.body.getReader();\n    let partialLine = '';\n    let finalResponse = '';\n    while (true) {\n      const {\n        done,\n        value\n      } = await reader.read();\n      if (done) {\n        updateBotReply(messageId, finalResponse, false); // Ensure typing is set to false when done\n        break;\n      }\n      const text = new TextDecoder().decode(value);\n      const lines = (partialLine + text).split('\\n');\n      partialLine = lines.pop();\n      for (const line of lines) {\n        try {\n          const json = JSON.parse(line);\n          if (json.response) {\n            finalResponse += json.response;\n            updateBotReply(messageId, finalResponse, true);\n          }\n        } catch (error) {\n          console.error('Error parsing JSON line:', line, error);\n        }\n      }\n    }\n  } catch (error) {\n    console.error('Fetching bot response failed:', error);\n    updateBotReply(messageId, \"Sorry, an error occurred. Please try again later.\", false);\n  } finally {\n    // Ensure that the loading state is set to false when done\n    dispatch({\n      type: 'SET_LOADING_STATE',\n      payload: false\n    });\n  }\n}","map":{"version":3,"names":["useState","useEffect","fetchBotReply","messageId","chatHistory","updateBotReply","persona","dispatch","cutoffString","cPrompt","JSON","stringify","cutoffIndex","lastIndexOf","chatPrompt","substring","length","systemPrompt","finalPrompt","console","log","repeat","type","payload","response","fetch","method","headers","body","model","prompt","ok","Error","status","reader","getReader","partialLine","finalResponse","done","value","read","text","TextDecoder","decode","lines","split","pop","line","json","parse","error"],"sources":["/home/aldan/Desktop/projects/Lush Void/tokenquill/github/TulpaTalk/src/components/hooks.js"],"sourcesContent":["import { useState, useEffect } from 'react';\n\n// chatHelpers.js\nexport async function fetchBotReply(messageId, chatHistory, updateBotReply, persona, dispatch) {\n  try {\n    const cutoffString = `\",\\n    \"content\": \"`;\n    const cPrompt = JSON.stringify(chatHistory, null, 2);\n    const cutoffIndex = cPrompt.lastIndexOf(cutoffString);\n    const chatPrompt = cPrompt.substring(0, cutoffIndex + cutoffString.length);\n    const systemPrompt = JSON.stringify(persona, null, 2);\n    const finalPrompt = `${systemPrompt}\\n\\n${chatPrompt}`;\n    console.log('-'.repeat(12)); // Corrected '*' to '-' and use 'repeat'\n    console.log(finalPrompt);\n    console.log();\n\n    dispatch({ type: 'SET_LOADING_STATE', payload: true });\n\n    const response = await fetch('http://localhost:11434/api/generate', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify({\n        model: persona.model,\n        prompt: finalPrompt,\n      }),\n    });\n\n    if (!response.ok) {\n      throw new Error(`HTTP error! Status: ${response.status}`);\n    }\n\n    const reader = response.body.getReader();\n    let partialLine = '';\n    let finalResponse = '';\n\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        updateBotReply(messageId, finalResponse, false); // Ensure typing is set to false when done\n        break;\n      }\n\n      const text = new TextDecoder().decode(value);\n      const lines = (partialLine + text).split('\\n');\n      partialLine = lines.pop();\n\n      for (const line of lines) {\n        try {\n          const json = JSON.parse(line);\n          if (json.response) {\n            finalResponse += json.response;\n            updateBotReply(messageId, finalResponse, true);\n          }\n        } catch (error) {\n          console.error('Error parsing JSON line:', line, error);\n        }\n      }\n    }\n  } catch (error) {\n    console.error('Fetching bot response failed:', error);\n    updateBotReply(messageId, \"Sorry, an error occurred. Please try again later.\", false);\n  } finally {\n    // Ensure that the loading state is set to false when done\n    dispatch({ type: 'SET_LOADING_STATE', payload: false });\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}